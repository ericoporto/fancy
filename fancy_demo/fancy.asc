// fancy module script

// Define maximum text tokens and stack size
#define MAX_TXTTK 1024
#define MAX_LINES 16
#define MAX_TAG_NEST 6

#region TEXT_TOKEN_REG
enum TkType
{
  eTkText = 0,
  eTkLinebreak,
  eTkBlank, 
  eTkGraphic
};

TextToken* _newLineBreakTxtToken()
{
  TextToken* tk = new TextToken;
  tk.type = eTkLinebreak;
  return tk;
}

TextToken* _newSpriteTxtToken(int sprite)
{
  TextToken* tk = new TextToken;
  tk.type = eTkGraphic;
  tk.font = sprite;
  tk.width = Game.SpriteWidth[sprite];
  tk.height = Game.SpriteHeight[sprite];
  return tk;
}

TextToken* _newTxtToken(String text, int text_begin, int text_length, int color, int outline_color, FontType font)
{
  TextToken* tk = new TextToken;
  tk.text_begin = text_begin;
  tk.text_length = text_length;
  tk.color = color;
  tk.outline_color = outline_color;
  tk.font = font;
  tk.width = GetTextWidth(text, font);
  tk.height = GetFontHeight(font);
  return tk;
}

int _AppendTxtTok(TextToken* txttk_arr[], int txttk_count, TextToken* tk)
{
  int i = txttk_count;
  
  txttk_arr[i] = tk;
  txttk_count++;
  return txttk_count;
}

int _InserTxtTok(TextToken* txttk_arr[], int txttk_count, TextToken* tk, int index)
{
  txttk_count++;
  for(int i = txttk_count; i>index; i--)
  {
    txttk_arr[i] = txttk_arr[i-1];
  }  
  txttk_arr[index] = tk;  
  return txttk_count;  
}

TextToken* [] _NewTxtTok()
{
  TextToken* txttk_arr[];
  txttk_arr = new TextToken [MAX_TXTTK];
  return txttk_arr;
}
#endregion // TEXT_TOKEN_REG

enum TagType
{
  eTagNone = 0,
  eTagColor,
  eTagOutlineColor, 
  eTagFont, 
  eTagSprite
};

#region STACK_OF_INT_REG
struct StackOfInt
{
  int items[MAX_TAG_NEST];
  int index;
  import void Push(int number);
  import int Pop();
};

void StackOfInt::Push(int number)
{
  this.items[this.index] = number;
  this.index++;
}

int StackOfInt::Pop()
{
  this.index--;
  return this.items[this.index];
}
#endregion // STACK_OF_INT_REG

// Get the type of tag in format [>tag_type<:data]
TagType _get_tag_type(String tag)
{
  int c = tag.Chars[0];
  switch (c) {
    case 'c': return eTagColor;
    case 'o': return eTagOutlineColor;
    case 'f': return eTagFont;
    case 's': return eTagSprite;
  }
  return eTagNone;
}

// Get the data from tag in format [tag_type:>data<]
int _get_tag_data(String tag, TagType tag_type)
{
  if (tag_type == eTagNone) return 0;
  int p = tag.IndexOf(":") + 1;
  if (p == 0) return -1;
  String data = tag.Substring(p, tag.Length-p);
  if (data.Chars[0] >= '0' && data.Chars[0] <= '9') return data.AsInt;
  return 0;
}

// Parse the input text for tags and generate text tokens
int _parse_text(TextToken* txttk_arr[], String text, FancyDrawingConfig* cfg)
{
  int len = text.Length;
  int color = cfg.TextColor;
  int outline_color = cfg.OutlineColor;
  FontType font = cfg.Font;
  String token = "";
  int token_start = 0;
  int token_length = 0;
  int txttk_count = 0;
  
  StackOfInt stk_font;
  StackOfInt stk_color;
  StackOfInt stk_outcolor;

  for (int i = 0; i < len; i++) {
    int c = text.Chars[i];

    if (c == '[') {
      if (token.Length > 0) {
        txttk_count = _AppendTxtTok(txttk_arr, txttk_count, _newTxtToken(token, token_start, token_length, color, outline_color, font));
        token = "";
        token_start = i - token_length;
        token_length = 0;
      }

      i++;
      bool is_closing = false;
      if (i < len && text.Chars[i] == '/') {
        is_closing = true;
        i++;
      }

      int j = i;
      while (j <= len && text.Chars[j] != ']') j++;
      int delta = j - i;

      String strtag = text.Substring(i, delta);
      TagType tag = _get_tag_type(strtag);
      TagType tdata = tag;
      if (is_closing) tdata = eTagNone;
      int data = _get_tag_data(strtag, tdata);
      switch (tag) {
        case eTagColor:
          if (is_closing) color = stk_color.Pop();
          else {
            stk_color.Push(color);
            color = data;
          }
          break;
        case eTagOutlineColor:
          if (is_closing) outline_color = stk_outcolor.Pop();
          else {
            stk_outcolor.Push(outline_color);
            outline_color = data;
          }
          break;
        case eTagFont:
          if (is_closing) font = stk_font.Pop();
          else {
            stk_font.Push(font);
            font = data;
          }
          break;
        // following tags have no closing elements
        case eTagSprite:
          txttk_count = _AppendTxtTok(txttk_arr, txttk_count, _newSpriteTxtToken(data));
          break;
      }

      i += delta + is_closing - 1;
      if (is_closing) {
        token_start = i;
      }
    } else if (c == ']') {
      // skip
    } else if (c == ' ' || c == '\n') {
      if (token.Length > 0) {
        txttk_count = _AppendTxtTok(txttk_arr, txttk_count, _newTxtToken(token, token_start, token_length, color, outline_color, font));
        token = "";
        token_start = i - token_length;
        token_length = 0;
      }
      txttk_count = _AppendTxtTok(txttk_arr, txttk_count, _newTxtToken(" ", i, 1, color, outline_color, font));
    } else {
      if (token.Length == 0) {
        token_start = i;
      }
      token = token.AppendChar(c);
      token_length++;
    }
  }
  if (token_length > 0) {
    txttk_count = _AppendTxtTok(txttk_arr, txttk_count, _newTxtToken(token, token_start, token_length, color, outline_color, font));
  }
  
  _AppendTxtTok(txttk_arr, txttk_count, null);
  return txttk_count;
}

int _do_word_wrapping(TextToken* tk_arr[], int tk_count, String text, int width)
{
  int line_height[MAX_LINES];
  int line_width[MAX_LINES];
  int line = 0;
  int w = 0;

  for (int i = 0; i < tk_count; i++) {
    TextToken* t = tk_arr[i];
    String word = "";
    if(t.type == eTkText) word = text.Substring(t.text_begin, t.text_length);
    
    bool is_wrap_linebreak = w + t.width > width;
    bool is_char_linebreak = word == "\n";
    if (word == " ") {
      t.type = eTkBlank; // Optimize for the draw step
    }

    if (is_wrap_linebreak || is_char_linebreak) {
      line++;
      w = 0;
      if (is_char_linebreak) {
        t.width = 0;
        t.type = eTkLinebreak;
      } else if (is_wrap_linebreak) {
        tk_count = _InserTxtTok(tk_arr, tk_count, _newLineBreakTxtToken(), i);
        i++; // advance i due to insertion
      }
    }
    if (t.height > line_height[line]) {
      line_height[line] = t.height;
    }
    w += t.width;
    line_width[line] = w;
  }
  line++;
    
  int max_width = 0;
  int box_height = 0;
  for (int i = 0; i < line; i++) {
    if (max_width < line_width[i]) {
      max_width = line_width[i];
    }
    box_height += line_height[i];
  }
  line = 0;
  
  for (int i = 0; i < tk_count; i++) {
    TextToken* t = tk_arr[i];
    t.line_height = line_height[line];
    t.line_width = line_width[line];
    t.box_width = max_width;
    t.box_height = box_height;
    
    // System.Log(eLogInfo, "(%d) bw %d lw %d tw %d lh %d, %d : %s", i, t.box_width, t.line_width, t.width, t.line_height, t.type, text.Substring(t.text_begin, t.text_length));
    // System.Log(eLogInfo, "(%d) len %d type %d : %s", i, t.text_length, t.type, text.Substring(t.text_begin, t.text_length));
    if (t.type == eTkLinebreak) {
      line++;
      t.line_width = line_width[line];
    }
  }
  return tk_count;
}

void _draw_string_outline(this DrawingSurface*, int x, int y, FontType font, String text, int outline_color, int outline_width)
{
  this.DrawingColor = outline_color;
  for(int i = -outline_width; i <= outline_width; i++) {
    for(int j = -outline_width; j <= outline_width; j++) {
      this.DrawString(x+i, y+j, font, text);
    }
  }
}

void _draw_text(DrawingSurface* surf, int x, int y, int color, int outline_color, int outline_width, FontType font, const string text)
{
  if(outline_color != COLOR_TRANSPARENT && outline_width > 0) {
    surf._draw_string_outline(x, y, font, text, outline_color, outline_width);
  }
  
  surf.DrawingColor = color;
  surf.DrawString(x, y, font, text);
}

void _draw_sprite(DrawingSurface* surf, int x, int y, int graphic)
{
  surf.DrawImage(x, y, graphic);
}

enum VerticalAlignment {
  eVAlignTop = 1,
  eVAlignMiddle = 2,
  eVAlignBottom = 4
};

int _get_align_x(HorizontalAlignment halign, int x, TextToken* t)
{
  switch(halign) {
    case eAlignRight:  return x + t.box_width - t.line_width;
    case eAlignCenter: return x + t.box_width/2 - t.line_width/2;
    default: return x; break;
  }
}

int _get_align_y(VerticalAlignment valign, int y, TextToken* t)
{
  switch(valign) {
    case eVAlignTop: return y; // do nothing
    case eVAlignMiddle: return y + t.line_height/2 - t.height/2; break;
    default: return y + t.line_height - t.height; break; // bottom by default      
  }
}

// Write text tokens on a surface
void _draw_tokens(TextToken* tk_arr[], int tk_count, DrawingSurface* surf, String text, int x, int y, int width, int partial, FancyDrawingConfig* cfg)
{
  if(tk_count <= 0) return;
  int r_x = x;
  int r_y = y;
  VerticalAlignment valign = ((cfg.TextAlign & eAlignHasTop) && true) * eVAlignTop + ((cfg.TextAlign & eAlignHasVerCenter ) && true) * eVAlignMiddle;
  HorizontalAlignment halign = ((cfg.TextAlign & eAlignHasRight) && true) * eAlignRight + ((cfg.TextAlign & eAlignHasHorCenter ) && true) * eAlignCenter;
  
  r_x = _get_align_x(halign, x, tk_arr[0]);
  int tk_len;
  
  for (int i = 0; i < tk_count; i++) {
    TextToken* t = tk_arr[i];
    int line_height = t.line_height;
    int draw_y = _get_align_y(valign, r_y, t);   
    
    switch (t.type) {
      case eTkLinebreak:
        r_x = _get_align_x(halign, x, t);        
        r_y += line_height;
        continue; // this will skip to next line and token
      case eTkText:
        tk_len = t.text_length;
        if(partial >= 0 && i == tk_count-1) tk_len = partial;
        _draw_text(surf, r_x, draw_y, t.color, t.outline_color, cfg.OutlineWidth, t.font, text.Substring(t.text_begin, tk_len));
        break;
      case eTkGraphic:
        _draw_sprite(surf, r_x, draw_y, t.font);
        break;
    }
    r_x += t.width;
  }
}

// ----------------------------------------------------------------------
// ---------------- fancy module public interface -----------------------
// ----------------------------------------------------------------------


static FancyDrawingConfig* FancyDrawingConfig::Create(FontType font, int color, int outline_color, int outline_width, Alignment align, int line_spacing)
{
  FancyDrawingConfig* cfg = new FancyDrawingConfig;
  cfg.Font = font;
  cfg.TextColor = color;
  cfg.OutlineColor = outline_color;
  cfg.OutlineWidth = outline_width;
  cfg.TextAlign = align;
  cfg.LineSpacing = line_spacing;
  return cfg;
}

// draw fancy text wrapped on a surface
void DrawFancyTextWrapped(this DrawingSurface*, int x, int y, int width, int color, FontType font, const string text)
{
  TextToken* txttk_arr[] = _NewTxtTok();
  FancyDrawingConfig* config = FancyDrawingConfig.Create(font, color);
  int tk_count = _parse_text(txttk_arr, text, config);
  tk_count = _do_word_wrapping(txttk_arr, tk_count, text, width);
  _draw_tokens(txttk_arr, tk_count, this, text, x, y, width, -1, config);
}

void FancyTextBase::SetDrawingConfig(FancyDrawingConfig* config)
{
  if(config == null) {
    config = FancyDrawingConfig.Create(0, 65535 /* white */);
  }
  this._cfg = config;
}
  
void FancyTextBase::SetDrawingArea(int x, int y, int width)
{
  this._x = x;
  this._y = y;
  this._width = width;
}

void FancyTextBase::SetFancyText(String text)
{
  if(this._cfg == null) { this.SetDrawingConfig(null); }
  if(this._width <= 0) { this._width = FANCY_INFINITE_WIDTH; }
  
  int font = this._cfg.Font;
  int color = this._cfg.TextColor;
  int width = this._width;
  
  TextToken* tk_arr[] = _NewTxtTok();
  int tk_count = _parse_text(tk_arr, text, this._cfg);
  tk_count = _do_word_wrapping(tk_arr, tk_count, text, width);
  this._tk_arr = tk_arr;
  this._tk_count = tk_count;
  this._text = text;
}
  
void FancyTextBase::Draw(DrawingSurface* surf)
{  
  TextToken* tk_arr[] = this._tk_arr;
  int tk_count = this._tk_count;
  int x = this._x;
  int y = this._y;
  int width = this._width;
  String text = this._text;
  _draw_tokens(tk_arr, tk_count, surf, text, x, y, width, -1, this._cfg);
}


bool get_IsTextBeingTyped(this FancyTypedText*)
{
  return !String.IsNullOrEmpty(this._text) && (this._typed_token_count < this._tk_count);
}

void FancyTypedText::Skip()
{  
  this._typed_token_count = this._tk_count;
  this._typed_token_len = -1;
}

void FancyTypedText::Tick()
{  
  if((this._typed_token_count >= this._tk_count && this._typed_token_len == -1) || String.IsNullOrEmpty(this._text)) return;
  
  int max_tk_len = 0;
  if(this._typed_token_count > 0) max_tk_len = this._tk_arr[this._typed_token_count-1].text_length;
    
  this._typed_token_len++;
  
  if (this._typed_token_len > max_tk_len) {
    this._typed_token_len = 0;
    this._typed_token_count++;
    
    if (this._typed_token_count > this._tk_count) {
      this._typed_token_count = this._tk_count;
      this._typed_token_len = -1;
    }
  }
}

void FancyTypedText::DrawTyped(DrawingSurface* surf)
{
  TextToken* tk_arr[] = this._tk_arr;
  int tk_count = this._typed_token_count;
  int partial = this._typed_token_len;
  int x = this._x;
  int y = this._y;
  int width = this._width;
  String text = this._text;
  _draw_tokens(tk_arr, tk_count, surf, text, x, y, width, partial, this._cfg);  
}

void FancyTypedText::Clear()
{
  this._text = "";
  this._tk_arr = null;
  this._tk_count = 0;
  this._typed_token_count = 0;
  this._typed_token_len = -1;
}

void FancyTypedText::Start(String text)
{  
  this.SetFancyText(text);
  this._typed_token_len = 0;
  this._typed_token_count = 0;
}
