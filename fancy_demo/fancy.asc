// fancy module script

#define MAX_TXTTK 1024
#define MAX_TXTST 32

struct TextToken {
  int color;
  FontType font;
  String text;
  int width;
  int height;
};
TextToken _txttk[MAX_TXTTK];
int _txttk_count;

void _AppendTxtTok(String text, int color, FontType font)
{
  int i = _txttk_count;
  _txttk[i].color = color;
  _txttk[i].font = font;
  _txttk[i].text = text;
  _txttk[i].width = GetTextWidth(text, font);
  _txttk[i].height = GetFontHeight(font);
  _txttk_count++;
}
void _ClearTxtTok()
{
  _txttk_count = 0;
}

enum TagType {
  eTagNone = 0, 
  eTagColor, 
  eTagFont  
};

struct StackOfInt
{
  int items[MAX_TXTST];

  int index;
  import void Push(int number);
  import int Pop();
  import void Clear();
};
void StackOfInt::Push(int number)
{
  this.items[this.index] = number;
  this.index++;
}
int StackOfInt::Pop()
{
  this.index--;
  return this.items[this.index];
}
void StackOfInt::Clear()
{
  this.index = 0;
}

StackOfInt _stk_font;
StackOfInt _stk_color;

TagType _get_tag_type(String tag)
{
  int c = tag.Chars[0];
  switch(c)
  {
    case 'c': // color
      return eTagColor;
    case 'f': // font
      return eTagFont;
  }
  return eTagNone;
}

int _get_tag_data(String tag, TagType tag_type)
{
  if(tag_type == eTagNone) return 0;
  int p = tag.IndexOf(":");
  if(p <= 0) return -1;
  p++;
    
  String data = tag.Substring(p, tag.Length - p);
  
  if(data.Chars[0] >= '0' && data.Chars[0] <= '9') return data.AsInt;
  return 0;
}

void _parse_text(String text, FontType base_font, int base_color)
{
  int len = text.Length;
  bool plain_text = true;
  int color = base_color;
  FontType font = base_font;
  String ttok = "";
  
  // first element is a fake to hold length as color
  _ClearTxtTok();
  _AppendTxtTok("", len, 0);

  for (int i=0; i < len; i++) {
    int c = text.Chars[i];
   // System.Log(eLogInfo, "%c", c);
    
    if(c == '[')
    {
      if(ttok.Length > 0) {
        _AppendTxtTok(ttok, color, font);
        ttok = "";
      }
      
      i++;
      bool is_closing = false;
      if(i < len && text.Chars[i] == '/') {
        is_closing = true;
        i++;
      }
      
      int j = i;
      while (j <= len && text.Chars[j] != ']') j++;
      int delta = j - i;
      
      String strtag = text.Substring(i, delta);
      TagType tag = _get_tag_type(strtag);
      TagType tdata = tag;
      if(is_closing) tdata = eTagNone;
      int data = _get_tag_data(strtag, tdata);
      switch(tag) {
        case eTagColor:
          if(is_closing) color = _stk_color.Pop();
          else {
            _stk_color.Push(color);
            color = data;
          }
          break;
        case eTagFont:
          if(is_closing) font = _stk_font.Pop();
          else {
            _stk_font.Push(font);
            font = data;
          }
          break;
      }
      
      i += delta + is_closing;
    }
    else if(c == ' ')
    {
      ttok = ttok.AppendChar(c);
      _AppendTxtTok(ttok, color, font);
      ttok = "";
    }
    else if(c == '\n')
    {
      _AppendTxtTok(ttok, color, font);
      _AppendTxtTok("\n", color, font);
      ttok = "";
    }
    else 
    {
      ttok = ttok.AppendChar(c);
    }
  }
  _AppendTxtTok(ttok, color, font);
}

void _draw_text(DrawingSurface* surf, int x, int y, int color, FontType font, const string text)
{
  surf.DrawingColor = color;
  surf.DrawString(x, y, font, text);  
}

void _write_tokens(DrawingSurface* surf, int x, int y, int width)
{
  int start_i, end_i, p_i; 
  int len;
  int r_x = x;
  int r_y = y;
  int w;
  int itk = 0;
  int color;
  int font;
  int word_width;
  int word_height;
  int line_height;
  String word;
  
  // fake initial token encodes as color
  len = _txttk[itk].color;
  itk++;
  
  
  for(; itk < _txttk_count; itk++)
  {
    word = _txttk[itk].text;
    font = _txttk[itk].font;
    color = _txttk[itk].color;
    word_width = _txttk[itk].width;
    word_height = _txttk[itk].height;
    
    int word_len = word.Length;
    
    if(word_len <= 0) continue;
    
    if(w + word_width > width || (word_len == 1 && word == "\n"))
    {
      // line break
      r_x = x;
      r_y += line_height;
      w = 0;      
      line_height = 0;
    }
    
    if(word_height > line_height) line_height = word_height;
    w += word_width;
    
    // do draw command
    _draw_text(surf, r_x, r_y, color, font, word);
    
    r_x += word_width;
  }
}

void DrawFancyTextWrapped(this DrawingSurface*, int x, int y, int width, int color, FontType font, const string text)
{
  _parse_text(text, font, color);
  _write_tokens(this, x, y, width);
}